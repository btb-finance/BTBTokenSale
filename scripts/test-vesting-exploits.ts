import { ethers } from "hardhat";
import { BTBToken, TokenSale, VestingNFT } from "../types/contracts";

async function main() {
    const BTB_TOKEN_ADDRESS = "0x3Bc21B0B248A0B5CB45A6DD23f5d689fD9fd0B6c";
    const TOKEN_SALE_ADDRESS = "0x2DE5bedF629994149F3ed4902E6189bfC60444ed";
    const VESTING_NFT_ADDRESS = "0x785A5128EF5eF59A8c53f7f578ce24F374b3497D";

    const btbToken = await ethers.getContractAt("BTBToken", BTB_TOKEN_ADDRESS) as BTBToken;
    const tokenSale = await ethers.getContractAt("TokenSale", TOKEN_SALE_ADDRESS) as TokenSale;
    const vestingNFT = await ethers.getContractAt("VestingNFT", VESTING_NFT_ADDRESS) as VestingNFT;

    // Create test users
    const [owner] = await ethers.getSigners();
    const user1 = ethers.Wallet.createRandom().connect(ethers.provider);
    const user2 = ethers.Wallet.createRandom().connect(ethers.provider);

    // Fund test users
    await owner.sendTransaction({
        to: user1.address,
        value: ethers.parseEther("0.01")
    });
    await owner.sendTransaction({
        to: user2.address,
        value: ethers.parseEther("0.01")
    });

    console.log("Test Setup:");
    console.log("Owner:", owner.address);
    console.log("User1:", user1.address);
    console.log("User2:", user2.address);

    try {
        console.log("\n=== TEST 1: Double Claim Prevention ===");
        // Buy tokens with vesting
        console.log("\nCreating vesting schedule for User1...");
        const vestingTx = await tokenSale.connect(user1).buyTokensVesting({ 
            value: ethers.parseEther("0.000001") 
        });
        await vestingTx.wait();

        // Get NFT ID (assuming 0 for first NFT)
        const nftId = 0n;
        console.log("Created NFT ID:", nftId);

        // Try to claim immediately
        console.log("\nTrying immediate claim...");
        try {
            const claim1 = await tokenSale.connect(user1).claimVestedTokens(nftId);
            await claim1.wait();
            const schedule1 = await vestingNFT.getVestingSchedule(nftId);
            console.log("First claim amount:", ethers.formatEther(schedule1.claimedAmount));

            // Try to claim again immediately
            console.log("\nTrying second immediate claim...");
            const claim2 = await tokenSale.connect(user1).claimVestedTokens(nftId);
            await claim2.wait();
            const schedule2 = await vestingNFT.getVestingSchedule(nftId);
            console.log("Second claim amount:", ethers.formatEther(schedule2.claimedAmount));
        } catch (error: any) {
            console.log("Claim error:", error.message.slice(0, 100));
        }

        console.log("\n=== TEST 2: NFT Transfer and Claim ===");
        // Transfer NFT to another user
        console.log("\nTransferring NFT to User2...");
        try {
            const transferTx = await vestingNFT.connect(user1).transferFrom(user1.address, user2.address, nftId);
            await transferTx.wait();
            console.log("NFT transferred successfully");

            // Try to claim with original owner
            console.log("\nTrying claim with original owner (User1)...");
            const oldOwnerClaim = await tokenSale.connect(user1).claimVestedTokens(nftId);
            await oldOwnerClaim.wait();
        } catch (error: any) {
            console.log("Transfer/Claim error:", error.message.slice(0, 100));
        }

        console.log("\n=== TEST 3: Claim After Vesting End ===");
        // Try to simulate end of vesting period
        const schedule = await vestingNFT.getVestingSchedule(nftId);
        console.log("\nVesting Schedule:");
        console.log("Start Time:", new Date(Number(schedule.startTime) * 1000));
        console.log("End Time:", new Date(Number(schedule.endTime) * 1000));
        console.log("Total Amount:", ethers.formatEther(schedule.totalAmount));
        console.log("Currently Claimed:", ethers.formatEther(schedule.claimedAmount));

        // Calculate how much should be vested now
        const currentTime = Math.floor(Date.now() / 1000);
        const timeElapsed = currentTime - Number(schedule.startTime);
        const vestingDuration = Number(schedule.endTime) - Number(schedule.startTime);
        const expectedVested = schedule.totalAmount * BigInt(timeElapsed) / BigInt(vestingDuration);
        console.log("\nExpected vested amount:", ethers.formatEther(expectedVested));

        console.log("\n=== TEST 4: Multiple Small Claims ===");
        // Try multiple small claims in succession
        for (let i = 0; i < 3; i++) {
            try {
                console.log(`\nClaim attempt ${i + 1}:`);
                const claimTx = await tokenSale.connect(user2).claimVestedTokens(nftId);
                await claimTx.wait();
                const updatedSchedule = await vestingNFT.getVestingSchedule(nftId);
                console.log("Claimed amount:", ethers.formatEther(updatedSchedule.claimedAmount));
            } catch (error: any) {
                console.log("Claim error:", error.message.slice(0, 100));
            }
            // Wait a second between claims
            await new Promise(resolve => setTimeout(resolve, 1000));
        }

        console.log("\n=== TEST 5: NFT Burning Prevention ===");
        try {
            // @ts-ignore - Attempting to call burn function if it exists
            const burnTx = await vestingNFT.connect(user2).burn(nftId);
            await burnTx.wait();
            console.log("NFT burned - This is a vulnerability!");
        } catch (error: any) {
            console.log("Burn prevented:", error.message.slice(0, 100));
        }

        console.log("\n=== TEST 6: Claim Amount Manipulation ===");
        try {
            // Try to claim a specific amount directly
            // @ts-ignore - Attempting to call non-existent function
            const manipulateTx = await tokenSale.connect(user2).claimSpecificAmount(nftId, ethers.parseEther("1000"));
            await manipulateTx.wait();
            console.log("Amount manipulation successful - This is a vulnerability!");
        } catch (error: any) {
            console.log("Manipulation prevented:", error.message.slice(0, 100));
        }

        // Final state check
        const finalSchedule = await vestingNFT.getVestingSchedule(nftId);
        const user2Balance = await btbToken.balanceOf(user2.address);
        
        console.log("\nFinal State:");
        console.log("NFT Owner:", await vestingNFT.ownerOf(nftId));
        console.log("Total Vesting Amount:", ethers.formatEther(finalSchedule.totalAmount));
        console.log("Total Claimed:", ethers.formatEther(finalSchedule.claimedAmount));
        console.log("User2 Token Balance:", ethers.formatEther(user2Balance));

    } catch (error: any) {
        console.error("\nTest failed:", error.message);
        if (error.data) {
            try {
                const decodedError = ethers.toUtf8String('0x' + error.data.slice(138));
                console.error("Decoded error:", decodedError);
            } catch (e) {
                console.error("Raw error data:", error.data);
            }
        }
    }
}

main()
    .then(() => process.exit(0))
    .catch((error) => {
        console.error(error);
        process.exit(1);
    });
